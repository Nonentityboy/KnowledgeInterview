<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>01：http报文结构是怎样的？ | 前端知识总结</title>
    <meta name="description" content="Curtin的前端笔记">
    
    
    <link rel="preload" href="/assets/css/0.styles.21921e3e.css" as="style"><link rel="preload" href="/assets/js/app.48230f4a.js" as="script"><link rel="preload" href="/assets/js/2.40514cff.js" as="script"><link rel="preload" href="/assets/js/10.3a0e310b.js" as="script"><link rel="prefetch" href="/assets/js/11.b88ce604.js"><link rel="prefetch" href="/assets/js/12.83047675.js"><link rel="prefetch" href="/assets/js/13.88cad58b.js"><link rel="prefetch" href="/assets/js/14.fd4e39a2.js"><link rel="prefetch" href="/assets/js/15.6905e4f3.js"><link rel="prefetch" href="/assets/js/16.e7ae0ef3.js"><link rel="prefetch" href="/assets/js/17.23f7abeb.js"><link rel="prefetch" href="/assets/js/18.4641eb40.js"><link rel="prefetch" href="/assets/js/19.ff9ade34.js"><link rel="prefetch" href="/assets/js/20.7dacf653.js"><link rel="prefetch" href="/assets/js/21.459308d5.js"><link rel="prefetch" href="/assets/js/22.3f247b8f.js"><link rel="prefetch" href="/assets/js/23.7ede22c9.js"><link rel="prefetch" href="/assets/js/24.4becad71.js"><link rel="prefetch" href="/assets/js/25.7f2936a1.js"><link rel="prefetch" href="/assets/js/26.86787d4e.js"><link rel="prefetch" href="/assets/js/27.87a89ce2.js"><link rel="prefetch" href="/assets/js/28.028a146f.js"><link rel="prefetch" href="/assets/js/29.f411fe6b.js"><link rel="prefetch" href="/assets/js/3.31e7ba5d.js"><link rel="prefetch" href="/assets/js/30.b8114b3f.js"><link rel="prefetch" href="/assets/js/31.d34ad50f.js"><link rel="prefetch" href="/assets/js/32.2ce53581.js"><link rel="prefetch" href="/assets/js/4.bc141a6a.js"><link rel="prefetch" href="/assets/js/5.c6d92b1b.js"><link rel="prefetch" href="/assets/js/6.a6eb11c3.js"><link rel="prefetch" href="/assets/js/7.c5723805.js"><link rel="prefetch" href="/assets/js/8.5922bc8a.js"><link rel="prefetch" href="/assets/js/9.fbe4dcf4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.21921e3e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端知识总结</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识图谱</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/feInterview/" class="nav-link">前端基础进阶</a></li><li class="dropdown-item"><!----> <a href="/feFramework/" class="nav-link">前端框架进阶</a></li><li class="dropdown-item"><!----> <a href="/csInterview/" class="nav-link router-link-active">计算机基础进阶</a></li><li class="dropdown-item"><!----> <a href="/JSalgorithm/" class="nav-link">算法与数据结构</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">参考</a></div><div class="nav-item"><a href="https://www.github.com/nonentityboy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识图谱</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/feInterview/" class="nav-link">前端基础进阶</a></li><li class="dropdown-item"><!----> <a href="/feFramework/" class="nav-link">前端框架进阶</a></li><li class="dropdown-item"><!----> <a href="/csInterview/" class="nav-link router-link-active">计算机基础进阶</a></li><li class="dropdown-item"><!----> <a href="/JSalgorithm/" class="nav-link">算法与数据结构</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">参考</a></div><div class="nav-item"><a href="https://www.github.com/nonentityboy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/csInterview/HTTP.html" class="active sidebar-link">HTTP协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_01：http报文结构是怎样的？" class="sidebar-link">01：http报文结构是怎样的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#起始行" class="sidebar-link">起始行</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#头部" class="sidebar-link">头部</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#空行" class="sidebar-link">空行</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#实体" class="sidebar-link">实体</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_02-如何理解-http-的请求方法？" class="sidebar-link">02. 如何理解 HTTP 的请求方法？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#有哪些请求方法？" class="sidebar-link">有哪些请求方法？</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#get-和-post-有什么区别？" class="sidebar-link">GET 和 POST 有什么区别？</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_03-如何理解-uri？" class="sidebar-link">03: 如何理解 URI？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#uri-的结构" class="sidebar-link">URI 的结构</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#uri-编码" class="sidebar-link">URI 编码</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_04-如何理解-http-状态码？" class="sidebar-link">04: 如何理解 HTTP 状态码？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_1xx" class="sidebar-link">1xx</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_2xx" class="sidebar-link">2xx</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_3xx" class="sidebar-link">3xx</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_4xx" class="sidebar-link">4xx</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_5xx" class="sidebar-link">5xx</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_05-简要概括一下-http-的特点？http-有哪些缺点？" class="sidebar-link">05: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#http-特点" class="sidebar-link">HTTP 特点</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#http-缺点" class="sidebar-link">HTTP 缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_06：如何解决-http-的队头阻塞问题？" class="sidebar-link">06：如何解决 HTTP 的队头阻塞问题？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#什么是-http-队头阻塞？" class="sidebar-link">什么是 HTTP 队头阻塞？</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#并发连接" class="sidebar-link">并发连接</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#域名分片" class="sidebar-link">域名分片</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#http队头阻塞与tcp队头阻塞区别" class="sidebar-link">http队头阻塞与tcp队头阻塞区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_07：-http头部的-content-系列字段了解多少？" class="sidebar-link">07： http头部的 Content 系列字段了解多少？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#数据格式" class="sidebar-link">数据格式</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#压缩方式" class="sidebar-link">压缩方式</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#支持语言" class="sidebar-link">支持语言</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#字符集" class="sidebar-link">字符集</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_08：讲一讲-cookie" class="sidebar-link">08：讲一讲 cookie ?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#cookie-简介" class="sidebar-link">Cookie 简介</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#cookie-属性" class="sidebar-link">Cookie 属性</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#作用域" class="sidebar-link">作用域</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#安全相关" class="sidebar-link">安全相关</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#cookie-的缺点" class="sidebar-link">Cookie 的缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_09：-什么是跨域？浏览器如何拦截响应？如何解决？" class="sidebar-link">09： 什么是跨域？浏览器如何拦截响应？如何解决？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#什么是跨域" class="sidebar-link">什么是跨域</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#cors" class="sidebar-link">CORS</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#简单请求" class="sidebar-link">简单请求</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#非简单请求" class="sidebar-link">非简单请求</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#jsonp" class="sidebar-link">JSONP</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_10：http-2-有哪些改进？" class="sidebar-link">10：HTTP/2 有哪些改进？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#二进制传输" class="sidebar-link">二进制传输</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#多路复用" class="sidebar-link">多路复用</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#header-压缩" class="sidebar-link">Header 压缩</a></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#服务端-push" class="sidebar-link">服务端 Push</a></li></ul></li><li class="sidebar-sub-header"><a href="/csInterview/HTTP.html#_11：quic-协议？" class="sidebar-link">11：QUIC 协议？</a></li></ul></li><li><a href="/csInterview/TCP-UDP.html" class="sidebar-link">TCP、UDP协议</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_01：http报文结构是怎样的？"><a href="#_01：http报文结构是怎样的？" aria-hidden="true" class="header-anchor">#</a> 01：http报文结构是怎样的？</h2> <p>对于 TCP，传输的时候分为两个部分：<code>TCP头</code> 和 <code>数据部分</code></p> <p>对 HTTP， 也是 header + body。</p> <div class="language- extra-class"><pre class="language-text"><code>起始行 + 头部 + 空行 + 实体
</code></pre></div><p>http <code>请求报文</code>和<code>响应报文</code>有一定区别，所以分开介绍。</p> <h3 id="起始行"><a href="#起始行" aria-hidden="true" class="header-anchor">#</a> 起始行</h3> <p>对于请求报文来说，起始行类似下面这样:</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /home HTTP/1.1</span>
</code></pre></div><p>也就是方法 + 路径 + http版本。</p> <p>对于响应报文来说，起始行一般张这个样:</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
</code></pre></div><ul><li><p>响应报文的起始行也叫做状态行。由http版本、状态码和原因三部分组成。</p></li> <li><p>在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接一个换行，严格遵循ABNF语法规范</p></li></ul> <h3 id="头部"><a href="#头部" aria-hidden="true" class="header-anchor">#</a> 头部</h3> <p>请求头和响应头在报文中的位置:
<img src="https://s1.ax1x.com/2020/06/20/N1P9mV.jpg" alt=""></p> <p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到http非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p> <ul><li>字段名不区分大小写</li> <li>字段名不允许出现空格，不可以出现下划线_</li> <li>字段名后面必须紧接着</li></ul> <h3 id="空行"><a href="#空行" aria-hidden="true" class="header-anchor">#</a> 空行</h3> <p>很重要，用来区分开头部和实体。</p> <p>问: 如果说在头部中间故意加一个空行会怎么样？</p> <p>那么空行后的内容全部被视为实体。</p> <h3 id="实体"><a href="#实体" aria-hidden="true" class="header-anchor">#</a> 实体</h3> <p>就是具体的数据了，也就是body部分。请求报文对应请求体, 响应报文对应响应体。</p> <h2 id="_02-如何理解-http-的请求方法？"><a href="#_02-如何理解-http-的请求方法？" aria-hidden="true" class="header-anchor">#</a> 02. 如何理解 HTTP 的请求方法？</h2> <h3 id="有哪些请求方法？"><a href="#有哪些请求方法？" aria-hidden="true" class="header-anchor">#</a> 有哪些请求方法？</h3> <p>http/1.1规定了以下请求方法(注意，都是大写):</p> <p>GET: 通常用来获取资源
HEAD: 获取资源的元信息
POST: 提交数据，即上传数据
PUT: 修改数据
DELETE: 删除资源(几乎用不到)
CONNECT: 建立连接隧道，用于代理服务器
OPTIONS: 列出可对资源实行的请求方法，用来跨域请求
TRACE: 追踪请求-响应的传输路径</p> <h3 id="get-和-post-有什么区别？"><a href="#get-和-post-有什么区别？" aria-hidden="true" class="header-anchor">#</a> GET 和 POST 有什么区别？</h3> <p>首先最直观的是语义上的区别。</p> <p>而后又有这样一些具体的差别:</p> <ul><li>从<code>副作用</code>的角度，Get 多用于无副作用，POST 多用于副作用。（副作用指对<code>服务器上的资源做改变</code>，搜索是无副作用的，注册是副作用的。）</li> <li>从<code>幂等性</code>的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，<code>服务器上资源的状态变化</code>，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。)</li> <li>从<code>缓存</code>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。Get 请求能缓存，Post 不能。</li> <li>从<code>编码</code>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。（Post 支持更多的编码类型且不对数据类型限制）</li> <li>从<code>参数</code>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li> <li>从<code>TCP的角度</code>，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li> <li>从<code>安全的角度</code>，Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</li> <li>Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术</li> <li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li></ul> <h2 id="_03-如何理解-uri？"><a href="#_03-如何理解-uri？" aria-hidden="true" class="header-anchor">#</a> 03: 如何理解 URI？</h2> <p><code>URI, 全称为(Uniform Resource Identifier)</code>, 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。</p> <p>但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p> <h3 id="uri-的结构"><a href="#uri-的结构" aria-hidden="true" class="header-anchor">#</a> URI 的结构</h3> <p>URI 真正最完整的结构是这样的。</p> <p><img src="https://s1.ax1x.com/2020/06/20/N1iy5D.png" alt=""></p> <p>可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。</p> <ul><li><p><code>scheme</code> 表示协议名，比如http, https, file等等。后面必须和://连在一起。</p></li> <li><p><code>user:passwd@</code> 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p></li> <li><p><code>host:port</code> 表示主机名和端口。</p></li> <li><p><code>path</code> 表示请求路径，标记资源所在位置。</p></li> <li><p><code>query</code> 表示查询参数，为key=val这种形式，多个键值对之间用&amp;隔开。</p></li> <li><p><code>fragment</code> 表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。</p></li></ul> <p>举个例子:</p> <div class="language- extra-class"><pre class="language-text"><code>https://www.baidu.com/s?wd=HTTP&amp;rsv_spt=1
</code></pre></div><p>这个 URI 中，https即scheme部分，www.baidu.com为host:port部分（注意，http 和 https 的默认端口分别为80、443），/s为path部分，而wd=HTTP&amp;rsv_spt=1就是query部分。</p> <h3 id="uri-编码"><a href="#uri-编码" aria-hidden="true" class="header-anchor">#</a> URI 编码</h3> <p>URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。</p> <p>因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。</p> <p>如，空格被转义成了%20.</p> <h2 id="_04-如何理解-http-状态码？"><a href="#_04-如何理解-http-状态码？" aria-hidden="true" class="header-anchor">#</a> 04: 如何理解 HTTP 状态码？</h2> <p>RFC 规定 HTTP 的状态码为三位数，被分为五类:</p> <p>1xx: 表示目前是协议处理的中间状态，还需要后续操作。
2xx: 表示成功状态。
3xx: 重定向状态，资源位置发生变动，需要重新请求。
4xx: 请求报文有误。
5xx: 服务器端发生错误。
接下来就一一分析这里面具体的状态码。</p> <h3 id="_1xx"><a href="#_1xx" aria-hidden="true" class="header-anchor">#</a> 1xx</h3> <p>101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。</p> <h3 id="_2xx"><a href="#_2xx" aria-hidden="true" class="header-anchor">#</a> 2xx</h3> <p>200 OK是见得最多的成功状态码。通常在响应体中放有数据。</p> <p>204 No Content含义与 200 相同，但响应头后没有 body 数据。</p> <p>206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断电续传，当然也会带上相应的响应头字段Content-Range。</p> <h3 id="_3xx"><a href="#_3xx" aria-hidden="true" class="header-anchor">#</a> 3xx</h3> <p>301 Moved Permanently即永久重定向，对应着302 Found，即临时重定向。</p> <p>302 found，临时性重定向，表示资源临时被分配了新的 URL</p> <p>比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p> <p>而如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。</p> <p>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</p> <p>304 Not Modified: 当协商缓存命中时会返回这个状态码。详见浏览器缓存</p> <h3 id="_4xx"><a href="#_4xx" aria-hidden="true" class="header-anchor">#</a> 4xx</h3> <p>400 Bad Request: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p> <p>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</p> <p>403 Forbidden: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p> <p>404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。</p> <p>405 Method Not Allowed: 请求方法不被服务器端允许。</p> <p>406 Not Acceptable: 资源无法满足客户端的条件。</p> <p>408 Request Timeout: 服务器等待了太长时间。</p> <p>409 Conflict: 多个请求发生了冲突。</p> <p>413 Request Entity Too Large: 请求体的数据过大。</p> <p>414 Request-URI Too Long: 请求行里的 URI 太大。</p> <p>429 Too Many Request: 客户端发送的请求过多。</p> <p>431 Request Header Fields Too Large请求头的字段内容太大。</p> <h3 id="_5xx"><a href="#_5xx" aria-hidden="true" class="header-anchor">#</a> 5xx</h3> <p>500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。</p> <p>501 Not Implemented: 表示客户端请求的功能还不支持。</p> <p>502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。</p> <p>503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。</p> <h2 id="_05-简要概括一下-http-的特点？http-有哪些缺点？"><a href="#_05-简要概括一下-http-的特点？http-有哪些缺点？" aria-hidden="true" class="header-anchor">#</a> 05: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h2> <h3 id="http-特点"><a href="#http-特点" aria-hidden="true" class="header-anchor">#</a> HTTP 特点</h3> <p>HTTP 的特点概括如下:</p> <ul><li><p><code>灵活可扩展</code>，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p></li> <li><p><code>可靠传输</code>。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</p></li> <li><p><code>请求-应答</code>。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</p></li> <li><p><code>无状态</code>。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</p></li></ul> <h3 id="http-缺点"><a href="#http-缺点" aria-hidden="true" class="header-anchor">#</a> HTTP 缺点</h3> <ul><li><p><code>无状态</code> 所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p></li> <li><p><code>明文传输</code> 即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p></li> <li><p><code>队头阻塞问题</code>. 当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<code>队头阻塞</code>问题。接下来会有一小节讨论这个问题。</p></li></ul> <h2 id="_06：如何解决-http-的队头阻塞问题？"><a href="#_06：如何解决-http-的队头阻塞问题？" aria-hidden="true" class="header-anchor">#</a> 06：如何解决 HTTP 的队头阻塞问题？</h2> <h3 id="什么是-http-队头阻塞？"><a href="#什么是-http-队头阻塞？" aria-hidden="true" class="header-anchor">#</a> 什么是 HTTP 队头阻塞？</h3> <p>从前面的小节可以知道，HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，<code>一旦队首的请求处理太慢，就会阻塞后面请求的处理</code>。这就是著名的HTTP队头阻塞问题。</p> <h3 id="并发连接"><a href="#并发连接" aria-hidden="true" class="header-anchor">#</a> 并发连接</h3> <p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p> <p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p> <h3 id="域名分片"><a href="#域名分片" aria-hidden="true" class="header-anchor">#</a> 域名分片</h3> <p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。</p> <p>比如 content1.xylkt.com 、content2.xylkt.com。</p> <p>这样一个xylkt.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p> <h3 id="http队头阻塞与tcp队头阻塞区别"><a href="#http队头阻塞与tcp队头阻塞区别" aria-hidden="true" class="header-anchor">#</a> http队头阻塞与tcp队头阻塞区别</h3> <p>http层面上的队头阻塞，是同一个长链接上的多个http请求之间的队头阻塞，只有前面的请求完事儿才轮到后面的请求；</p> <p>tcp的队头阻塞是数据包层面的，一个请求被分成有序的多个小的数据包，只有序号靠前的包确认完整接收，后续的包才能被处理；否则就不处理一直等这个包重传,这个机制导致的TCP层面的队头阻塞</p> <h2 id="_07：-http头部的-content-系列字段了解多少？"><a href="#_07：-http头部的-content-系列字段了解多少？" aria-hidden="true" class="header-anchor">#</a> 07： http头部的 Content 系列字段了解多少？</h2> <p>对于Content系列字段的介绍分为四个部分: 数据格式、压缩方式、支持语言和字符集。</p> <h3 id="数据格式"><a href="#数据格式" aria-hidden="true" class="header-anchor">#</a> 数据格式</h3> <p>上一节谈到 HTTP 灵活的特性，它支持非常多的数据格式，那么这么多格式的数据一起到达客户端，客户端怎么知道它的格式呢？</p> <p>当然，最低效的方式是直接猜，有没有更好的方式呢？直接指定可以吗？</p> <p>答案是肯定的。不过首先需要介绍一个标准——<code>MIME(Multipurpose Internet Mail Extensions</code>, 多用途互联网邮件扩展)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。</p> <p>因此，HTTP 从MIME type取了一部分来标记报文 body 部分的数据类型，这些类型体现在 Content-Type 这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用Accept字段。</p> <p>具体而言，这两个字段的取值可以分为下面几类:</p> <div class="language-http extra-class"><pre class="language-http"><code>text： text/html, text/plain, text/css 等
<span class="token header-name keyword">image:</span> image/gif, image/jpeg, image/png 等
audio/video: audio/mpeg, video/mp4 等
<span class="token header-name keyword">application:</span> application/json, application/javascript, application/pdf, application/octet-stream
</code></pre></div><h3 id="压缩方式"><a href="#压缩方式" aria-hidden="true" class="header-anchor">#</a> 压缩方式</h3> <p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的Content-Encoding字段上， 同样的，接收什么样的压缩方式体现在了接受方的Accept-Encoding字段上。这个字段的取值有下面几种：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">gzip:</span> 当今最流行的压缩格式
<span class="token header-name keyword">deflate:</span> 另外一种著名的压缩格式
<span class="token header-name keyword">br:</span> 一种专门为 HTTP 发明的压缩算法


// 发送端
<span class="token header-name keyword">Content-Encoding:</span> gzip
// 接收端
<span class="token header-name keyword">Accept-Encoding:</span> gizp
</code></pre></div><h3 id="支持语言"><a href="#支持语言" aria-hidden="true" class="header-anchor">#</a> 支持语言</h3> <p>对于发送方而言，还有一个Content-Language字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为Accept-Language。如:</p> <div class="language-http extra-class"><pre class="language-http"><code>// 发送端
<span class="token header-name keyword">Content-Language:</span> zh-CN, zh, en
// 接收端
<span class="token header-name keyword">Accept-Language:</span> zh-CN, zh, en
</code></pre></div><h3 id="字符集"><a href="#字符集" aria-hidden="true" class="header-anchor">#</a> 字符集</h3> <p>最后是一个比较特殊的字段, 在接收端对应为Accept-Charset，指定可以接受的字符集，而在发送端并没有对应的Content-Charset, 而是直接放在了Content-Type中，以charset属性指定。如:</p> <div class="language- extra-class"><pre class="language-text"><code>// 发送端
Content-Type: text/html; charset=utf-8
// 接收端
Accept-Charset: charset=utf-8
</code></pre></div><p>最后以一张图来总结一下吧:
<img src="https://s1.ax1x.com/2020/06/20/N1Aavj.png" alt=""></p> <h2 id="_08：讲一讲-cookie"><a href="#_08：讲一讲-cookie" aria-hidden="true" class="header-anchor">#</a> 08：讲一讲 cookie ?</h2> <h3 id="cookie-简介"><a href="#cookie-简介" aria-hidden="true" class="header-anchor">#</a> Cookie 简介</h3> <p>前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？</p> <p>HTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的Set-Cookie字段来对客户端写入Cookie。举例如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 请求头</span>
Cookie<span class="token punctuation">:</span> a<span class="token operator">=</span>xxx<span class="token punctuation">;</span>b<span class="token operator">=</span>xxx
<span class="token comment">// 响应头</span>
Set<span class="token operator">-</span>Cookie<span class="token punctuation">:</span> a<span class="token operator">=</span>xxx
<span class="token keyword">set</span><span class="token operator">-</span>Cookie<span class="token punctuation">:</span> b<span class="token operator">=</span>xxx
</code></pre></div><h3 id="cookie-属性"><a href="#cookie-属性" aria-hidden="true" class="header-anchor">#</a> Cookie 属性</h3> <p>生存周期</p> <ul><li>Cookie 的有效期可以通过Expires和Max-Age两个属性来设置。</li> <li>Expires即过期时间</li> <li>Max-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。</li></ul> <h3 id="作用域"><a href="#作用域" aria-hidden="true" class="header-anchor">#</a> 作用域</h3> <p>关于作用域也有两个属性: Domain和path, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，/表示域名下的任意路径都允许使用 Cookie。</p> <h3 id="安全相关"><a href="#安全相关" aria-hidden="true" class="header-anchor">#</a> 安全相关</h3> <p>如果 cookie 字段带上<code>HttpOnly</code>，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p> <p>相应的，对于 CSRF 攻击的预防，也有SameSite属性。</p> <p>SameSite可以设置为三个值，Strict、Lax和None。</p> <ul><li><p>a. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。</p></li> <li><p>b. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</p></li> <li><p>c. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。</p></li></ul> <h3 id="cookie-的缺点"><a href="#cookie-的缺点" aria-hidden="true" class="header-anchor">#</a> Cookie 的缺点</h3> <ul><li><p>容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。</p></li> <li><p>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过Domain和Path指定作用域来解决。</p></li> <li><p>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</p></li></ul> <h2 id="_09：-什么是跨域？浏览器如何拦截响应？如何解决？"><a href="#_09：-什么是跨域？浏览器如何拦截响应？如何解决？" aria-hidden="true" class="header-anchor">#</a> 09： 什么是跨域？浏览器如何拦截响应？如何解决？</h2> <p>前后端分离的开发模式中，经常会遇到跨域问题，即 Ajax 请求发出去了，服务器也成功响应了，前端就是拿不到这个响应。接下来我们就来好好讨论一下这个问题。</p> <h3 id="什么是跨域"><a href="#什么是跨域" aria-hidden="true" class="header-anchor">#</a> 什么是跨域</h3> <p>回顾一下 URI 的组成:
<img src="https://s1.ax1x.com/2020/06/20/N1iy5D.png" alt=""></p> <p>浏览器遵循同源政策(scheme(协议)、host(主机)和port(端口)都相同则为同源)。非同源站点有这样一些限制:</p> <ul><li>不能读取和修改对方的 DOM</li> <li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li> <li>限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)</li></ul> <p>当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为跨域请求。</p> <blockquote><p>跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。</p></blockquote> <h3 id="cors"><a href="#cors" aria-hidden="true" class="header-anchor">#</a> CORS</h3> <p>CORS 其实是 W3C 的一个标准，全称是<code>跨域资源共享</code>。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: <code>简单请求</code>和<code>非简单请求</code>。</p> <p>浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于简单请求:</p> <ul><li>请求方法为 GET、POST 或者 HEAD</li> <li>请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)</li></ul> <blockquote><p>浏览器画了这样一个圈，在这个圈里面的就是简单请求, 圈外面的就是非简单请求，然后针对这两种不同的请求进行不同的处理。</p></blockquote> <h3 id="简单请求"><a href="#简单请求" aria-hidden="true" class="header-anchor">#</a> 简单请求</h3> <p>请求发出去之前，浏览器做了什么？</p> <p>它会自动在请求头当中，添加一个Origin字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应地添加<code>Access-Control-Allow-Origin</code>字段，如果Origin不在这个字段的范围中，那么浏览器就会将响应拦截。</p> <p>因此，<code>Access-Control-Allow-Origin</code> 字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。</p> <p><code>Access-Control-Allow-Credentials</code>。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为true, 并且在前端也需要设置withCredentials属性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><p>Access-Control-Expose-Headers。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）, 还能拿到这个字段声明的响应头字段。比如这样设置:</p> <div class="language- extra-class"><pre class="language-text"><code>Access-Control-Expose-Headers: aaa
</code></pre></div><p>那么在前端可以通过 XMLHttpRequest.getResponseHeader('aaa') 拿到 aaa 这个字段的值。</p> <h3 id="非简单请求"><a href="#非简单请求" aria-hidden="true" class="header-anchor">#</a> 非简单请求</h3> <p>非简单请求相对而言会有些不同，体现在两个方面: 预检请求和响应字段。</p> <p>我们以 PUT 方法为例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'http://xxx.com'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'X-Custom-Header'</span><span class="token punctuation">,</span> <span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当这段代码执行后，首先会发送预检请求。这个预检请求的请求行和请求体是下面这个格式:</p> <div class="language-http extra-class"><pre class="language-http"><code>OPTIONS / HTTP/1.1
<span class="token header-name keyword">Origin:</span> 当前地址
<span class="token header-name keyword">Host:</span> xxx.com
<span class="token header-name keyword">Access-Control-Request-Method:</span> PUT
<span class="token header-name keyword">Access-Control-Request-Headers:</span> X-Custom-Header
</code></pre></div><p>预检请求的方法是<code>OPTIONS</code>，同时会加上Origin源地址和Host目标地址，这很简单。同时也会加上两个关键的字段:</p> <div class="language-http extra-class"><pre class="language-http"><code>Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法
Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头
</code></pre></div><p>这是预检请求。接下来是响应字段，响应字段也分为两部分，一部分是对于预检请求的响应，一部分是对于 CORS 请求的响应。</p> <p>预检请求的响应。如下面的格式:</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token response-status">HTTP/1.1 <span class="token property">200 OK</span></span>
<span class="token header-name keyword">Access-Control-Allow-Origin:</span> *
<span class="token header-name keyword">Access-Control-Allow-Methods:</span> GET, POST, PUT
<span class="token header-name keyword">Access-Control-Allow-Headers:</span> X-Custom-Header
<span class="token header-name keyword">Access-Control-Allow-Credentials:</span> true
<span class="token header-name keyword">Access-Control-Max-Age:</span> 1728000
<span class="token header-name keyword">Content-Type:</span> text/html; charset=utf-8
<span class="token header-name keyword">Content-Encoding:</span> gzip
<span class="token header-name keyword">Content-Length:</span> 0
</code></pre></div><p>其中有这样几个关键的响应头字段:</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Access-Control-Allow-Origin:</span> 表示可以允许请求的源，可以填具体的源名，也可以填*表示允许任意源请求。
<span class="token header-name keyword">Access-Control-Allow-Methods:</span> 表示允许的请求方法列表。
<span class="token header-name keyword">Access-Control-Allow-Credentials:</span> 简单请求中已经介绍。
<span class="token header-name keyword">Access-Control-Allow-Headers:</span> 表示允许发送的请求头字段
<span class="token header-name keyword">Access-Control-Max-Age:</span> 预检请求的有效期，在此期间，不用发出另外一条预检请求。
</code></pre></div><p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的CORS请求也不会发出去了。</p> <blockquote><p>CORS 请求的响应。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和简单请求的情况是一样的。浏览器自动加上Origin字段，服务端响应头返回Access-Control-Allow-Origin。可以参考以上简单请求部分的内容。</p></blockquote> <h3 id="jsonp"><a href="#jsonp" aria-hidden="true" class="header-anchor">#</a> JSONP</h3> <p>虽然XMLHttpRequest对象遵循同源政策，但是script标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">jsonp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callbackName <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">generateURL</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dataStr <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&amp;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callbackName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dataStr<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化回调函数名称</span>
    callbackName <span class="token operator">=</span> callbackName <span class="token operator">||</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">// 创建 script 元素并加入到当前文档中</span>
    <span class="token keyword">let</span> scriptEle <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    scriptEle<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token function">generateURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 绑定到 window 上，为了后面调用</span>
    window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// script 执行完了，成为无用元素，需要清除</span>
      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然在服务端也会有响应的操作, 以 express 为例:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>query
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
  <span class="token comment">// 注意哦，返回给script标签，浏览器直接把这部分字符串执行</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">('数据包')</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
前端这样简单地调用一下就好了<span class="token punctuation">:</span>

<span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  url<span class="token punctuation">:</span> <span class="token string">'http://localhost:3000'</span><span class="token punctuation">,</span>
  params<span class="token punctuation">:</span> <span class="token punctuation">{</span> 
    a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拿到数据进行处理</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数据包</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>和CORS相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p></blockquote> <h2 id="_10：http-2-有哪些改进？"><a href="#_10：http-2-有哪些改进？" aria-hidden="true" class="header-anchor">#</a> 10：HTTP/2 有哪些改进？</h2> <p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p> <p>在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了<code>同一个域名下的请求数量</code>，当页面中需要请求很多资源的时候，<code>队头阻塞（Head of line blocking）</code>会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p> <h3 id="二进制传输"><a href="#二进制传输" aria-hidden="true" class="header-anchor">#</a> 二进制传输</h3> <p>HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p> <p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-43760.png" alt=""></p> <h3 id="多路复用"><a href="#多路复用" aria-hidden="true" class="header-anchor">#</a> 多路复用</h3> <p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</p> <ul><li>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流</li> <li>流也就是多个帧组成的数据流。</li></ul> <blockquote><p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p></blockquote> <p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043800.png" alt=""></p> <h3 id="header-压缩"><a href="#header-压缩" aria-hidden="true" class="header-anchor">#</a> Header 压缩</h3> <p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p> <p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p> <h3 id="服务端-push"><a href="#服务端-push" aria-hidden="true" class="header-anchor">#</a> 服务端 Push</h3> <p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p> <p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。</p> <h2 id="_11：quic-协议？"><a href="#_11：quic-协议？" aria-hidden="true" class="header-anchor">#</a> 11：QUIC 协议？</h2> <p>这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标很远大，希望替代 TCP 协议。</p> <ul><li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制</li> <li>实现了自己的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已经实现了 0-RTT 了</li> <li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包
<ul><li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li> <li>在丢失两个包或以上的情况就使用重传机制，因为算不出来了</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/21/2020, 12:29:41 AM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/csInterview/TCP-UDP.html">TCP、UDP协议</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.48230f4a.js" defer></script><script src="/assets/js/2.40514cff.js" defer></script><script src="/assets/js/10.3a0e310b.js" defer></script>
  </body>
</html>
