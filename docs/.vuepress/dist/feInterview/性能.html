<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>01: 讲一下前端缓存? | 前端知识总结</title>
    <meta name="description" content="Curtin的前端笔记">
    
    
    <link rel="preload" href="/assets/css/0.styles.21921e3e.css" as="style"><link rel="preload" href="/assets/js/app.86c2b150.js" as="script"><link rel="preload" href="/assets/js/2.40514cff.js" as="script"><link rel="preload" href="/assets/js/24.c856f6aa.js" as="script"><link rel="prefetch" href="/assets/js/10.003b2367.js"><link rel="prefetch" href="/assets/js/11.e073bcea.js"><link rel="prefetch" href="/assets/js/12.290cbd2b.js"><link rel="prefetch" href="/assets/js/13.b2a3e8e2.js"><link rel="prefetch" href="/assets/js/14.e6ad2632.js"><link rel="prefetch" href="/assets/js/15.aa22c079.js"><link rel="prefetch" href="/assets/js/16.ec6a2ee0.js"><link rel="prefetch" href="/assets/js/17.75bff12e.js"><link rel="prefetch" href="/assets/js/18.76fc4e0b.js"><link rel="prefetch" href="/assets/js/19.d3d23519.js"><link rel="prefetch" href="/assets/js/20.39d73449.js"><link rel="prefetch" href="/assets/js/21.ea67d3a1.js"><link rel="prefetch" href="/assets/js/22.a2361e51.js"><link rel="prefetch" href="/assets/js/23.87fb54fe.js"><link rel="prefetch" href="/assets/js/25.6bccff74.js"><link rel="prefetch" href="/assets/js/26.c44d8e1c.js"><link rel="prefetch" href="/assets/js/27.f713e7b1.js"><link rel="prefetch" href="/assets/js/28.1ae0e8c5.js"><link rel="prefetch" href="/assets/js/29.9c35b6ab.js"><link rel="prefetch" href="/assets/js/3.31e7ba5d.js"><link rel="prefetch" href="/assets/js/30.06f633db.js"><link rel="prefetch" href="/assets/js/31.b181a037.js"><link rel="prefetch" href="/assets/js/4.bc141a6a.js"><link rel="prefetch" href="/assets/js/5.012a9a4a.js"><link rel="prefetch" href="/assets/js/6.e1b676af.js"><link rel="prefetch" href="/assets/js/7.e919403f.js"><link rel="prefetch" href="/assets/js/8.a9705983.js"><link rel="prefetch" href="/assets/js/9.628ab312.js">
    <link rel="stylesheet" href="/assets/css/0.styles.21921e3e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端知识总结</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识图谱</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/feInterview/" class="nav-link router-link-active">前端基础进阶</a></li><li class="dropdown-item"><!----> <a href="/feFramework/" class="nav-link">前端框架进阶</a></li><li class="dropdown-item"><!----> <a href="/csInterview/" class="nav-link">计算机基础进阶</a></li><li class="dropdown-item"><!----> <a href="/JSalgorithm/" class="nav-link">算法与数据结构</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://www.github.com/nonentityboy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">知识图谱</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/feInterview/" class="nav-link router-link-active">前端基础进阶</a></li><li class="dropdown-item"><!----> <a href="/feFramework/" class="nav-link">前端框架进阶</a></li><li class="dropdown-item"><!----> <a href="/csInterview/" class="nav-link">计算机基础进阶</a></li><li class="dropdown-item"><!----> <a href="/JSalgorithm/" class="nav-link">算法与数据结构</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://www.github.com/nonentityboy" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/feInterview/HTML.html" class="sidebar-link">HTML相关</a></li><li><a href="/feInterview/CSS.html" class="sidebar-link">CSS</a></li><li><a href="/feInterview/JS_base.html" class="sidebar-link">JS基础</a></li><li><a href="/feInterview/JS_array.html" class="sidebar-link">JS深入数组</a></li><li><a href="/feInterview/JS_V8.html" class="sidebar-link">JS深入V8引擎</a></li><li><a href="/feInterview/JS_promise.html" class="sidebar-link">JS-异步I/O及异步编程</a></li><li><a href="/feInterview/性能.html" class="active sidebar-link">性能相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/feInterview/性能.html#_01-讲一下前端缓存" class="sidebar-link">01: 讲一下前端缓存?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/feInterview/性能.html#强缓存" class="sidebar-link">强缓存</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#协商缓存" class="sidebar-link">协商缓存</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#两者对比" class="sidebar-link">两者对比</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#缓存位置" class="sidebar-link">缓存位置</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#_02-浏览器本地存储-各自优劣" class="sidebar-link">02: 浏览器本地存储? 各自优劣?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/feInterview/性能.html#cookie" class="sidebar-link">Cookie</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#localstorage" class="sidebar-link">localStorage</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#sessionstorage" class="sidebar-link">sessionStorage</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#indexdb" class="sidebar-link">IndexDB</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#总结-2" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#_03-防抖节流实现一下" class="sidebar-link">03: 防抖节流实现一下</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#_04-图片懒加载" class="sidebar-link">04: 图片懒加载?</a></li><li class="sidebar-sub-header"><a href="/feInterview/性能.html#_05-如果一个页面很卡-说一下优化" class="sidebar-link">05: 如果一个页面很卡,说一下优化?</a></li></ul></li><li><a href="/feInterview/浏览器-安全.html" class="sidebar-link">浏览器-安全相关</a></li><li><a href="/feInterview/浏览器-渲染.html" class="sidebar-link">浏览器-渲染相关</a></li><li><a href="/feInterview/前端工程化.html" class="sidebar-link">前端工程化</a></li><li><a href="/feInterview/跨端开发.html" class="sidebar-link">跨端开发实践</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_01-讲一下前端缓存"><a href="#_01-讲一下前端缓存" aria-hidden="true" class="header-anchor">#</a> 01: 讲一下前端缓存?</h2> <p>缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。接下来以三个部分来把浏览器的缓存机制说清楚：</p> <ul><li>强缓存</li> <li>协商缓存</li> <li>缓存位置</li></ul> <h3 id="强缓存"><a href="#强缓存" aria-hidden="true" class="header-anchor">#</a> 强缓存</h3> <p>浏览器中的缓存作用分为两种情况，一种是需要发送HTTP请求，一种是不需要发送。</p> <p>首先是检查强缓存，这个阶段不需要发送HTTP请求。</p> <p>如何来检查呢？通过相应的字段来进行，但是说起这个字段就有点门道了。</p> <p>在HTTP/1.0和HTTP/1.1当中，这个字段是不一样的。在早期，也就是HTTP/1.0时期，使用的是Expires，而HTTP/1.1使用的是Cache-Control。让我们首先来看看Expires。</p> <h4 id="expires"><a href="#expires" aria-hidden="true" class="header-anchor">#</a> Expires</h4> <p>Expires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p> <p>Expires: Wed, 22 Nov 2019 08:41:00 GMT
表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求。</p> <p>这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。</p> <h4 id="cache-control"><a href="#cache-control" aria-hidden="true" class="header-anchor">#</a> Cache-Control</h4> <p>在HTTP1.1中，采用了一个非常关键的字段：Cache-Control。这个字段也是存在于</p> <p>它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age。比如这个例子:</p> <p>Cache-Control:max-age=3600
代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。</p> <p>它其实可以组合非常多的指令，完成更多场景的缓存判断, 将一些关键的属性列举如下: public: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。</p> <ul><li><p>private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</p></li> <li><p>no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。</p></li> <li><p>no-store：非常粗暴，不进行任何形式的缓存。</p></li> <li><p>s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。</p></li> <li><p>must-revalidate: 是缓存就会有过期的时候，加上这个字段一旦缓存过期，就必须回到源服务器验证。</p></li></ul> <p>值得注意的是，当<code>Expires</code>和<code>Cache-Control</code>同时存在的时候，<code>Cache-Control</code>会优先考虑。</p> <p>当然，还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——协商缓存了。</p> <h3 id="协商缓存"><a href="#协商缓存" aria-hidden="true" class="header-anchor">#</a> 协商缓存</h3> <p>强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。</p> <p>具体来说，这样的缓存tag分为两种: Last-Modified 和 ETag。这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存的两个 tag 不一样。</p> <h4 id="last-modified"><a href="#last-modified" aria-hidden="true" class="header-anchor">#</a> Last-Modified</h4> <p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p> <p>浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。</p> <p>服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:</p> <p>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
否则返回304，告诉浏览器直接用缓存。</p> <h4 id="etag"><a href="#etag" aria-hidden="true" class="header-anchor">#</a> ETag</h4> <p>ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。</p> <p>浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。</p> <p>服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:</p> <p>如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
否则返回304，告诉浏览器直接用缓存。</p> <h3 id="两者对比"><a href="#两者对比" aria-hidden="true" class="header-anchor">#</a> 两者对比</h3> <p>在精准度上，ETag优于Last-Modified。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。
另外，如果两种方式都支持的话，服务器会优先考虑ETag。</p> <h3 id="缓存位置"><a href="#缓存位置" aria-hidden="true" class="header-anchor">#</a> 缓存位置</h3> <p>前面我们已经提到，当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？</p> <p>浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：</p> <p>Service Worker
Memory Cache
Disk Cache
Push Cache</p> <h4 id="service-worker"><a href="#service-worker" aria-hidden="true" class="header-anchor">#</a> Service Worker</h4> <p>Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。</p> <p>Service Worker 同时也是 PWA 的重要实现机制，关于它的细节和特性，我们将会在后面的 PWA 的分享中详细介绍。</p> <h4 id="memory-cache-和-disk-cache"><a href="#memory-cache-和-disk-cache" aria-hidden="true" class="header-anchor">#</a> Memory Cache 和 Disk Cache</h4> <p>Memory Cache指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p> <p>Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。稍微有些计算机基础的应该很好理解，就不展开了。</p> <p>好，现在问题来了，既然两者各有优劣，那浏览器如何决定将资源放进内存还是硬盘呢？主要策略如下：</p> <p>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
内存使用率比较高的时候，文件优先进入磁盘</p> <h4 id="push-cache"><a href="#push-cache" aria-hidden="true" class="header-anchor">#</a> Push Cache</h4> <p>即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。关于 Push Cache，有非常多的内容可以挖掘，不过这已经不是本文的重点，大家可以参考这篇扩展文章。</p> <h3 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>对浏览器的缓存机制来做个简要的总结:</p> <ul><li><p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用</p></li> <li><p>如果强缓存可用，直接使用</p> <ul><li>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>这些条件请求字段检查资源是否更新</li> <li>若资源更新，返回资源和200状态码</li> <li>否则，返回304，告诉浏览器直接从缓存获取资源</li></ul></li></ul> <h2 id="_02-浏览器本地存储-各自优劣"><a href="#_02-浏览器本地存储-各自优劣" aria-hidden="true" class="header-anchor">#</a> 02: 浏览器本地存储? 各自优劣?</h2> <p>浏览器的本地存储主要分为<code>Cookie</code>、<code>WebStorage</code>和<code>IndexDB</code>, 其中<code>WebStorage</code>又可以分为<code>localStorage</code>和<code>sessionStorage</code>。接下来我们就来一一分析这些本地存储方案。</p> <h3 id="cookie"><a href="#cookie" aria-hidden="true" class="header-anchor">#</a> Cookie</h3> <p>Cookie 最开始被设计出来其实并不是来做本地存储的，而是为了弥补HTTP在状态管理上的不足。</p> <p>HTTP 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，故事就这样结束了，但是下次发请求如何让服务端知道客户端是谁呢？</p> <p>这种背景下，就产生了 Cookie.</p> <blockquote><p>Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。</p></blockquote> <p>Cookie 的作用很好理解，就是用来做状态存储的，但它也是有诸多致命的缺陷的：</p> <p>容量缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。</p> <p>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。</p> <p>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</p> <h3 id="localstorage"><a href="#localstorage" aria-hidden="true" class="header-anchor">#</a> localStorage</h3> <p>localStorage有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage。</p> <p>不过它相对Cookie还是有相当多的区别的:</p> <ul><li><p>容量。localStorage 的容量上限为5M，相比于Cookie的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。</p></li> <li><p>只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。</p></li> <li><p>接口封装。通过localStorage暴露在全局，并通过它的 setItem 和 getItem等方法进行操作，非常方便。</p></li></ul> <h4 id="操作方式"><a href="#操作方式" aria-hidden="true" class="header-anchor">#</a> 操作方式</h4> <p>接下来我们来具体看看如何来操作localStorage。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">&quot;keting&quot;</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">18</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;keting&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&quot;info&quot;</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>接着进入相同的域名时就能拿到相应的值:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> name <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> info <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;info&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>localStorage其实存储的都是字符串，如果是存储对象需要调用JSON的stringify方法，并且用JSON.parse来解析成对象。</p></blockquote> <h4 id="应用场景"><a href="#应用场景" aria-hidden="true" class="header-anchor">#</a> 应用场景</h4> <p>利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源，比如官网的logo，存储Base64格式的图片资源，因此利用localStorage</p> <h3 id="sessionstorage"><a href="#sessionstorage" aria-hidden="true" class="header-anchor">#</a> sessionStorage</h3> <p>sessionStorage以下方面和localStorage一致:</p> <p>容量。容量上限也为 5M。
只存在客户端，默认不参与与服务端的通信。
接口封装。除了sessionStorage名字有所变化，存储方式、操作方式均和localStorage一样。
但sessionStorage和localStorage有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分sessionStorage就不复存在了。</p> <h4 id="应用场景-2"><a href="#应用场景-2" aria-hidden="true" class="header-anchor">#</a> 应用场景</h4> <p>可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。
可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用sessionStorage就再合适不过了。事实上微博就采取了这样的存储方式。</p> <h3 id="indexdb"><a href="#indexdb" aria-hidden="true" class="header-anchor">#</a> IndexDB</h3> <p>IndexDB是运行在浏览器中的非关系型数据库, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。</p> <p>关于它的使用，本文侧重原理，而且 MDN 上的教程文档已经非常详尽，这里就不做赘述了，感兴趣可以看一下使用文档。</p> <p>接着我们来分析一下IndexDB的一些重要特性，除了拥有数据库本身的特性，比如支持事务，存储二进制数据，还有这样一些特性需要格外注意：</p> <p>键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。
异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
受同源策略限制，即无法访问跨域的数据库。</p> <h3 id="总结-2"><a href="#总结-2" aria-hidden="true" class="header-anchor">#</a> 总结</h3> <p>浏览器中各种本地存储和缓存技术的发展，给前端应用带来了大量的机会，PWA 也正是依托了这些优秀的存储方案才得以发展起来。重新梳理一下这些本地存储方案:</p> <p>cookie并不适合存储，而且存在非常多的缺陷。
Web Storage包括localStorage和sessionStorage, 默认不会参与和服务器的通信。
IndexDB为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。</p> <h2 id="_03-防抖节流实现一下"><a href="#_03-防抖节流实现一下" aria-hidden="true" class="header-anchor">#</a> 03: 防抖节流实现一下</h2> <h2 id="_04-图片懒加载"><a href="#_04-图片懒加载" aria-hidden="true" class="header-anchor">#</a> 04: 图片懒加载?</h2> <h2 id="_05-如果一个页面很卡-说一下优化"><a href="#_05-如果一个页面很卡-说一下优化" aria-hidden="true" class="header-anchor">#</a> 05: 如果一个页面很卡,说一下优化?</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/17/2020, 10:17:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/feInterview/JS_promise.html" class="prev">JS-异步I/O及异步编程</a></span> <span class="next"><a href="/feInterview/浏览器-安全.html">浏览器-安全相关</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.86c2b150.js" defer></script><script src="/assets/js/2.40514cff.js" defer></script><script src="/assets/js/24.c856f6aa.js" defer></script>
  </body>
</html>
