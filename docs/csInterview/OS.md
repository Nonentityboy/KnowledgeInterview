# 操作系统面试之道

## 1.操作系统特征

并发、共享、虚拟、异步

## 2. 并发、并行区别

并发：使多个任务交替的执行
并行：同时处理多个任务

最关键的点就是：是否是『同时』

## 3.进程和线程的区别 和 联系

（1）区别：
进程是资源分配的最小单位，线程是CPU调度的最小单位；
不同进程间数据很难共享，同一进程下不同线程间数据很易共享；
进程拥有自己的地址空间，而线程没有。

（2）联系：
进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。
进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文
线程是共享了进程的上下文环境的更为细小的CPU时间段。

## 4. 进程通信方式（5种）

- 管道：将一个程序的输出作为另一个程序的输入 ----》优点：简单；   缺点：一个进程往管道输入数据，则会阻塞等待别的进程从管道读取数据
- 消息队列：从一个进程向另一个进程发送一个数据 -----》优点：解决阻塞；   缺点：进程从消息队列中读取数据到内存消耗时间
- 共享内存：系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。即两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中。-----》 优点：解决耗时；      缺点：多进程竞争内存（两个进程同时抢一块内存，谁也不让谁，导致卡死）
- 信号量：本质是一个计数器，用来实现进程之间的互斥与同步。 -------》优点：解决竞态。
- Socket：最常见的方式。比如 淘宝APP 与 淘宝服务器之间的通信。


## 5. 操作系统内存管理（3种方式）

（1）分区：进程加载匹配的单位是分区，进程和分区是是一对一的关系。 分区属于物理地址。

三种分区算法：

- 最佳适配，选择与要求大小最接近的块
- 首次适配，从开始扫描内存，选择大小足够的第一个可用块
- 下次适配，从上一次放置的位置开始扫描内存，选择下一个大小足够的可用块

问题：内存碎片，造成内存空间上的浪费

（2）分页：一个进程对应多个页。页属于逻辑地址。

- 页的组成（3部分）：页（page）  一定大小字节数内存单元，属于逻辑单元。进程中所有代码、数据等信息均按页进行存储，属于逻辑组织形式。每个页有页码及其他信息。
- 页框(page frame)  对应页字节数的物理内存，属于物理单元，是实际存在于物理内存中的可用地址单元。页框相当于页的容器，进程运行过程中，可能会动态加载不同页进入页框，CPU则直接对页框进行存取。  
- 页表（page table）  既然有页和对应页框，那就必须有映射表将两者联系起来，而页表就是页和页框之间的映射表。换言之，知道页就可以查询到页框，知道页框，也可以查询到对应页。

（3）分段：一个进程对应多个段。

同 分页。只是 段 比 页 更小了。

## 6. 银行家算法

两种题型
（1）判断状态是否安全：
找 Available <= 当前资源数 的 进程1，然后进行分配，分配结束后， 当前资源数 += Allocation；
重复上述步骤，如果均可以进行，则得出安全序列 { 进程1， 进程2， ... }, 状态安全；反之，不安全。
（2）进程提出请求request，系统能否分配：
request <= need, 下一步
request <= Avaiable, 下一步
修改数据为 Avaiable = Avaiable - request, Allocation = Allocation + request, Need = Need - Request ,然后按照（1），判断是否安全，安全则系统能分配

## 7. 死锁

（1）定义：
两个或多个进程被无限期地阻塞、相互等待的一种状态。

（2）产生死锁的必要条件：

- 互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
- 请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
- 非抢占条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
- 循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

（3）如何处理死锁问题：

- 忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
- 检测死锁并且恢复。
- 仔细地对资源进行动态分配，使系统始终处于安全状态以避免死锁。
- 通过破除死锁四个必要条件之一，来防止死锁产生。

## 8. 进程同步遵循的原则

　（1）空闲让进；
　（2）忙则等待（保证对临界区的互斥访问）；
　（3）有限等待（有限代表有限的时间，避免死等）；
　（4）让权等待，（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）。

## 9. 线程分类（2类）

（1）用户级线程(user level thread)：对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程被成为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。

（2）内核级线程(kernel level thread)：对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以实现真正的并行计算。

## 10. 进程调度算法

（1）FIFO或First Come, First Served (FCFS)先来先服务
（2）Shortest Job First (SJF)
（3）Shortest Remaining Job First (SRJF)： SJF升级版
（4）优先权调度
每个任务关联一个优先权，调度优先权最高的任务。
注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。
（5）Round-Robin(RR)轮转调度算法
设置一个时间片，按时间片来轮转调度（“轮叫”算法）
优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；
时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。










